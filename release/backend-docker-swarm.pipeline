pipeline {
    agent any

    environment {
        buildId = "${UUID.randomUUID().toString()}"
        app = null
        fullImageName = '';
        imageDefinition = ''
        containerDefinition = ''
        integrationDefinition = null
        regionHomolog = null
        regionGreen = null
        regionBlue = null
    }

    stages {
        stage("Start") {
            steps {
                timeout(time: 15, unit: 'SECONDS') {
                    script {
                        input message: "Start pipeline?', ok: 'Confirm!"
                    }
                }
            }
        }

        stage("Load parameters") {
            steps {
                script {
                    params = loadParameters()
                    app = params.app
                    mainBranch = params.main_branch
                    imageDefinition = params.image_definition
                    containerDefinition = params.container_definition
                    integrationDefinition = params.integration_definition
                    regionHomolog = params.regions[0]
                    regionProd = params.regions[1]
                }
                wrap([$class: 'BuildUser']) {
                    script {
                        USER_ID = "${BUILD_USER}"
                    }
                }
            }
        }

        stage("Build Image") {
            steps {
                script {
                    fullImageName = "${imageDefinition.name}:${buildId}"

                    docker.withRegistry("http://${imageDefinition.registry_host}") {
                        def customImage = docker.build("${fullImageName}", "-f ${imageDefinition.docker_file} .")
                        customImage.push()
                    }
                }
            }
        }

        stage("Deploy Homolog") {
            steps {
                deployToRegion(regionHomolog)
            }
        }

        stage("Temporary Production Deployment") {
            when {
                branch mainBranch
            }
            steps {
                deployTemporaryToRegion(regionProd)
            }
        }

        stage("Validate Temporary Service") {
            when {
                branch mainBranch
            }
            steps {
                script {
                    input message: "${regionProd.name} is Healthy?", ok: "Yes!"
                }
            }
        }

        stage("Production Rollout") {
            when {
                branch mainBranch
            }
            steps {
                deployToRegionWithSwarm(regionProd)
            }
        }

        stage("Cleanup") {
            when {
                branch mainBranch
            }
            steps {
                cleanupTemporaryService(regionProd)
            }
        }

    }
    post {
        failure {
            createFailureNotification()
        }

        aborted {
            createAbortNotification()
        }
    }  
}

def deployToRegion(region) {
    timeout(time: 5, unit: 'MINUTES') {
        script {
            input message: "Start deploy ${region.name}', ok: 'Confirm!"
            createNotification("Deploy Region ${region.name}", "iniciado")
            
            def remote = connectToRegion(region)
            def env = extractEnvironmentVariables(region.env_file)

            deploy(remote, containerDefinition.external_port, env)
            createNotification("Deploy Region ${region.name}", "finalizado")
        }
    }
}

def deploy(remote,externalPort,env){

    def containerExists=sshCommand remote: remote, command: "sudo docker ps --filter 'name=${containerDefinition.name}' -q";
    
    if(containerExists){
        sshCommand remote: remote, command: "sudo docker rm -f ${containerDefinition.name}"
    }

    def volumeFlag="";
     
    if(containerDefinition.volume){
         volumeFlag="-v ${containerDefinition.volume}"}

    sshCommand remote: remote, command: 
        "sudo docker run -d --restart unless-stopped -p ${externalPort}:${containerDefinition.internal_port} --memory ${containerDefinition.memory} --log-opt max-size=${containerDefinition.log_max_size} --log-opt max-file=${containerDefinition.log_max_file} -h=${remote.hostname} ${volumeFlag} ${env} --name ${containerDefinition.name} ${imageDefinition.registry_host}/${fullImageName}"
}

def deployTemporaryToRegion(region) {
    def externalPortTemp = containerDefinition.external_port + 100
    def env = extractEnvironmentVariables(region.env_file)

    def remote = connectToRegion(region)
    deployTemporaryServiceWithSwarm(remote, externalPortTemp, env)
    
    def healthCheckUri = "http://${remote.host}:${externalPortTemp}/${integrationDefinition.healt_check_endpoint}"
    createHealthCheckNotification(region.name, healthCheckUri)
}

def deployToRegionWithSwarm(region) {
    def env = extractEnvironmentVariables(region.env_file)
    def remote = connectToRegion(region)
    
    deployWithSwarm(remote, containerDefinition.external_port, env)
    createNotification("Deploy Region ${region.name}", "completed")
}

def cleanupTemporaryService(region) {
    def remote = connectToRegion(region)
    removeTemporaryService(remote)
}

def connectToRegion(region) {
    boolean connected = false
    def connectedHost
    for (host in region.manager_hosts) {
        try {
            def remote = buildRemote(host, region.name)
            connectedHost = host
            connected = true
            break
        } catch (com.jcraft.jsch.JSchException e) {
            echo "Falha ao conectar-se ao host: $host. Tentando o próximo..."
        }
    }
    if (!connected) {
        error "Não foi possível conectar-se a nenhum host."
    }
    return remote
}


def extractEnvironmentVariables(envFile){

     if(!envFile) {
         return "";
     }

      def content = readYaml (file: envFile);

      def concatEnv="";

      for(item in content.environment_variables){
           concatEnv+="-e ${item.name}='${item.value}' ";
      }

      return concatEnv;
}

def buildRemote(host,regionName,user,password){

    def dockerRemote=[:]
    dockerRemote.name = 'remote'
    dockerRemote.host = host
    dockerRemote.hostname="${containerDefinition.name}-region-${regionName.toLowerCase()}"
    dockerRemote.user= user
    dockerRemote.password= password
    dockerRemote.allowAnyHosts = true

    return dockerRemote;
}

def loadParameters(){
  def params = readYaml (file: '.jenkins-pipelines/deployment.params.yml')
  return params;
}

def createDeployNotification(regionName,host,status){

    def notification="""
 ```
user: ${USER_ID}
build id: ${buildId}
build number: ${env.BUILD_NUMBER}
branch: ${env.GIT_BRANCH}
host: ${host}
image name: ${fullImageName}
container definition
    name: ${containerDefinition.name}
    memory: ${containerDefinition.memory}
    external_port: ${containerDefinition.external_port}
    log_max_file: ${containerDefinition.log_max_file}
    log_max_size: ${containerDefinition.log_max_size}
    volume: ${containerDefinition.volume}
```
"""
    notifyOnDiscord("Deploy Region ${regionName} - ${status}",notification,integrationDefinition.discord_web_hook_notification)
}

def createHealthCheckNotification(regionName,healthCheckUri){

    def notification="""
### O deploy na region ${regionName} foi executado.

> Para validar, execute um health check usando [este link](${healthCheckUri})

ApÃ³s validar o teste, acesse a [pipeline](${env.BUILD_URL}) e confirme o *rollout*.
    """

    notifyOnDiscord("Deploy Region ${regionName}",notification,integrationDefinition.discord_web_hook_notification)
}

def createFailureNotification(){

    def notification="### A execuÃ§Ã£o da pipeline ${env.BUILD_URL} falhou."

    notifyOnDiscord("Falhou",notification,integrationDefinition.discord_web_hook_notification)
}

def createAbortNotification(){

    def notification="### A execuÃ§Ã£o da pipeline ${env.BUILD_URL} foi cancelada."

    notifyOnDiscord("Cancelou",notification,integrationDefinition.discord_web_hook_notification)
}

def notifyOnDiscord(title,description,webhookUrl) {

    def curlScript="curl -X POST ${webhookUrl} -s -H 'Content-Type: application/x-www-form-urlencoded' -d 'username=${app.name} - ${title}&content=${description}' "

    sh(script:curlScript, returnStdout: false)
}
